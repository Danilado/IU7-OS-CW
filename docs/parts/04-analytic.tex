\section{Аналитический раздел}

\subsection{Постановка задачи}

Операционные системы на базе ядра Linux предоставляют унифицированный стек ввода, включающий обработку событий от устройств типа «мышь» и доставку событий в пользовательское пространство через стандартные интерфейсы ядра и графические подсистемы~\cite{linux-input-docs,linux-driver-basics}. Мобильные устройства на базе Android, как правило, оснащены сенсорными экранами и стеком беспроводной связи Bluetooth, обеспечивающим двунаправленный обмен данными с персональными компьютерами~\cite{bluetooth-core-spec,android-bt-connect}. Эти свойства позволяют построить программный комплекс, в котором сенсорный экран телефона выступает источником данных для формирования команд управления курсором на компьютере.

В соответствии с заданием на курсовую работу, утверждённым руководителем курсовой работы, необходимо разработать загружаемый модуль ядра Linux, реализующий виртуальное устройство мыши, принимающий команды от мобильного приложения на смартфоне по каналу Bluetooth и преобразующий эти команды в события подсистемы ввода~\cite{linux-driver-basics,linux-input-docs}. Мобильное приложение осуществляет обработку касаний сенсорного экрана и элементов пользовательского интерфейса на основании которых, формируются сообщения с параметрами перемещений курсора и состояниями кнопок~\cite{android-bt-connect,BluetoothSocket-doc}.

С точки зрения мобильного устройства задача состоит в формировании и отправке на компьютер последовательности сообщений, содержащих сведения о:
\begin{itemize}
	\item относительном смещении точки касания по экрану, сопоставляемом с перемещением курсора;
	\item состояниях кнопок манипулятора (левая и правая кнопки), задаваемых элементами интерфейса мобильного приложения.
\end{itemize}

Задача загружаемого модуля ядра сводится к приёму сообщений от телефона, декодированию параметров перемещения и состояний кнопок, генерации соответствующих событий в подсистеме ввода Linux и их доставке приложениям рабочего стола как событий стандартного устройства типа мышь~\cite{linux-input-docs}. 

Для реализации указанной системы в рамках курсовой работы требуется:
\begin{itemize}
	\item выбрать механизм представления виртуального устройства мыши в ядре Linux;
	\item выбрать механизм генерации событий ввода курсора и кнопок из загружаемого модуля ядра;
	\item выбрать способ приёма данных по Bluetooth непосредственно в модуле ядра и механизм взаимодействия с приложением Android;
	\item разработать формат пакета, передаваемого с телефона в модуль ядра, и протокол обмена на уровне прикладной сессии;
	\item обеспечить корректную обработку входящих сообщений в модуле ядра и согласованную генерацию событий ввода для виртуального устройства мыши.
\end{itemize}

\subsection{Способы управления курсором мыши из загружаемого модуля ядра}

Подсистема ввода ядра Linux представляет абстракцию устройств ввода в виде структуры \texttt{struct input\_dev}. Драйверы регистрируют такие устройства в ядре, после чего события от них транслируются в стандартные интерфейсы \texttt{/dev/input} и, далее, в графические подсистемы и оконные менеджеры~\cite{linux-input-docs,input-programming}. Для управления курсором из загружаемого модуля рассматриваются три класса подходов:
\begin{enumerate}
	\item регистрация виртуального устройства ввода в подсистеме input;
	\item генерация событий через подсистему \texttt{uinput} из пользовательского пространства;
	\item интеграция с подсистемой HID с эмуляцией HID-манипулятора.
\end{enumerate}

\subsubsection*{Виртуальное устройство в подсистеме input}

Базовый способ генерации событий мыши из загружаемого модуля ядра заключается в регистрации виртуального устройства ввода через подсистему input~\cite{linux-input-docs,input-programming}. Драйвер выделяет и инициализирует структуру \texttt{struct input\_dev}, заполняя сведения об идентификаторе устройства и поддерживаемых типах событий, а затем регистрирует её в input-core, после чего в системе появляется соответствующее устройство мыши~\cite{linux-input-docs}. Для устройства мыши обычно указываются типы событий \texttt{EV\_REL} (относительное перемещение по осям \texttt{REL\_X}, \texttt{REL\_Y}) и \texttt{EV\_KEY} (нажатия \texttt{BTN\_LEFT}, \texttt{BTN\_RIGHT})~\cite{linux-input-docs,linux-hid-docs,hidintro}.

Генерация событий для зарегистрированного устройства выполняется специализированными функциями подсистемы ввода, такими как \texttt{input\_report\_rel}, \texttt{input\_report\_key} и \texttt{input\_sync}, которые обновляют внутреннее состояние устройства и доставляют события всем подписанным обработчикам~\cite{linux-input-docs,input-programming}. В контексте разрабатываемого драйвера каждое поступившее сообщение от смартфона интерпретируется как набор элементарных действий мыши (смещение по осям и изменение состояний кнопок) и преобразуется в одну или несколько последовательностей вызовов указанных функций. Такой подход обеспечивает интеграцию с архитектурой ввода и делает виртуальное устройство неотличимым от аппаратной мыши для остального программного обеспечения~\cite{linux-input-docs,linux-hid-docs}.

\subsubsection*{Подсистема \texorpdfstring{\texttt{uinput}}{uinput} и генерация событий из пользовательского пространства}

Подсистема \texttt{uinput} реализует интерфейс, позволяющий пользовательским процессам создавать виртуальные устройства ввода и генерировать события от их имени через специальное символьное устройство \texttt{/dev/uinput}~\cite{uinput-docs,linux-input-docs}. Пользовательское приложение описывает возможности устройства, после чего отправляет структуры \texttt{struct input\_event}, которые ядро интерпретирует как события подсистемы ввода~\cite{uinput-docs,input-programming}. Этот механизм применяется для реализации эмуляторов устройств ввода и прикладных программ, инжектирующих события в пользовательском пространстве.

Для решения рассматриваемой задачи применение \texttt{uinput} означало бы перенос логики приёма данных по Bluetooth и обработки протокола с модуля ядра в пользовательское приложение, которое затем транслировало бы события мыши через \texttt{/dev/uinput}. При таком подходе загружаемый модуль ядра фактически не участвовал бы в формировании событий, а являлся бы вспомогательным компонентом либо полностью отсутствовал. Этот подход не совпадает с утверждённым заданием на курсовую работу.

\subsubsection*{Интеграция с подсистемой HID и интерфейс UHID}

Подсистема HID ядра Linux обеспечивает поддержку устройств ввода, реализующих стандартный HID-протокол (клавиатуры, мыши, графические планшеты и др.), и опирается на разделение на транспортные драйверы и HID-core~\cite{linux-hid-docs,hidintro,hid-transport}. Транспортный драйвер отвечает за доставку HID-отчётов от конкретной шины (USB, Bluetooth и т.п.), а HID-core интерпретирует отчёты, формируя события подсистемы ввода~\cite{linux-hid-docs,hiddev-doc}. Интерфейс UHID предоставляет возможность создавать HID-устройства из пользовательского пространства: пользовательский процесс взаимодействует с устройством \texttt{/dev/uhid}, отправляя события, которые далее обрабатываются HID-core и преобразуются в события ввода~\cite{uhid-doc,linux-hid-docs}.

Использование HID-подсистемы для эмуляции мыши обеспечивает совместимость с существующим стеком драйверов и поддержкой HID в ядре~\cite{linux-hid-docs,hidintro}. Однако для учебной задачи, в которой акцент сделан на реализации логики непосредственно в модуле ядра, такой подход требует разработки HID-дескриптора, генерации корректных HID-отчётов и учёта дополнительных особенностей HID-профиля, что усложняет структуру драйвера без необходимости использования расширенных возможностей HID-протокола~\cite{hid-transport,hiddev-doc}.

\subsubsection*{Другие способы вмешательства в стек ввода}

На практике применяются подходы, основанные на перехвате или модификации событий на поздних этапах стека ввода, например через перехват операций устройств \lstinline|/dev/input/eventX| или вмешательство в обработчики графической подсистемы~\cite{linux-input-docs}. Такие решения опираются на модификацию существующих драйверов либо на установку промежуточных слоёв между ядром и пользовательскими приложениями. Для курсовой работы по разработке загружаемого модуля ядра эти варианты не соответствуют постановке задачи, так как не создают отдельного драйвера мыши, а изменяют поведение уже существующих компонентов.

\subsubsection*{Обоснование выбора подсистемы input и виртуального устройства мыши}

Сопоставление рассмотренных подходов позволяет сформулировать следующие выводы:
\begin{itemize}
	\item регистрация виртуального устройства через подсистему input обеспечивает интеграцию с ядром, контролируемый набор зависимостей и представление мыши в системе как стандартного устройства ввода, управляемого загружаемым модулем ядра~\cite{linux-input-docs,input-programming};
	\item использование \texttt{uinput} переносит ключевую логику в пользовательское пространство и приводит к тому, что основная часть функциональности оказывается реализованной вне модуля ядра~\cite{linux-driver-basics,uinput-docs};
	\item интеграция через HID и UHID требует разработки HID-дескриптора и обработки HID-отчётов, что не является необходимым для эмуляции мыши с фиксированным набором событий, но усложняет реализацию драйвера~\cite{linux-hid-docs,hidintro}.
\end{itemize}

В связи с этим в разрабатываемой системе выбран подход, основанный на регистрации виртуального устройства мыши в подсистеме input и генерации событий с помощью функций подсистемы ввода из загружаемого модуля ядра~\cite{linux-input-docs,input-programming}.
Этот способ обладает достаточным функционалом для выполнения работы и совпадает с утверждённым заданием.

\subsection{Способы обмена данными между телефоном и модулем ядра по Bluetooth}

Стек Bluetooth в Linux реализуется в виде подсистемы \texttt{BlueZ}, включающей поддержку базового протокола L2CAP, протокола RFCOMM, профиля HID и вспомогательных служб~\cite{bluetooth-core-spec,bluez-l2cap-wiki,bluez-rfcomm-wiki}. На уровне ядра для взаимодействия с Bluetooth-устройствами используются сокеты семейства \texttt{PF\_BLUETOOTH} с такими протоколами, как \texttt{BTPROTO\_L2CAP} и \texttt{BTPROTO\_RFCOMM}~\cite{bluetooth-core-spec,kernel-net-kapi}. В пространстве ядра доступен интерфейс для создания и использования таких сокетов, обеспечивающий работу с Bluetooth-соединениями без участия пользовательского процесса~\cite{kernel-net-kapi}.

С точки зрения обмена данными между смартфоном и модулем ядра возможны следующие варианты:
\begin{enumerate}
	\item использование RFCOMM-сокетов в пространстве ядра;
	\item работа непосредственно с L2CAP в пространстве ядра;
	\item задействование профиля HID поверх Bluetooth;
	\item использование устройств \texttt{/dev/rfcommN} и пользовательского пространства.
\end{enumerate}

\subsubsection*{RFCOMM-сокеты в пространстве ядра}

Протокол RFCOMM реализует поверх L2CAP байтовый поток, логически аналогичный последовательному порту, и применяется для построения сервисов, требующих надёжного двунаправленного канала~\cite{bluetooth-core-spec,bluez-rfcomm-wiki}. В ядре Linux поддержка RFCOMM интегрирована в сетевой стек, что позволяет создавать серверные и клиентские сокеты с использованием семейства \texttt{PF\_BLUETOOTH} и протокола \texttt{BTPROTO\_RFCOMM}~\cite{bluetooth-core-spec,linux-rfcomm-core}. Адресация RFCOMM-сокета выполняется с использованием структуры адреса, содержащей семейство, Bluetooth-адрес удалённого устройства и номер канала.

На стороне Android-приложения подключение к такому сервису реализуется через API класса \texttt{BluetoothSocket}, который инкапсулирует установление RFCOMM-соединения по указанному UUID сервиса~\cite{android-bt-connect,BluetoothSocket-doc}. Таким образом реализуется связка: серверный RFCOMM-сокет в пространстве ядра и клиентское соединение в приложении Android.

При использовании RFCOMM модуль ядра получает поток байтов непосредственно от смартфона, что позволяет задать прикладной протокол управления курсором (например, фиксированный формат кадров с координатами и битовой маской кнопок) без вовлечения дополнительных уровней абстракции~\cite{bluetooth-core-spec,bluez-rfcomm-wiki}. Обработка входящего потока выполняется в  обработчиках на стороне загружаемого модуля ядра, что упрощает синхронизацию с подсистемой ввода~\cite{kernel-net-kapi}.

\subsubsection*{Использование L2CAP в пространстве ядра}

L2CAP представляет собой базовый протокол Bluetooth, обеспечивающий мультиплексирование каналов и передачу пакетов между устройствами~\cite{bluetooth-core-spec,bluez-l2cap-wiki}. Прямое использование L2CAP даёт доступ к более низкому уровню стека и предоставляет гибкость при реализации собственных протоколов, но требует дополнительной обработки параметров канала и управления MTU~\cite{l2cap-man}.

В контексте рассматриваемой задачи использование L2CAP в качестве средства передачи данных для прикладного протокола управления курсором приводит к усложнению логики модуля ядра и дублированию функциональности, уже реализованной в RFCOMM, как надстройке над L2CAP~\cite{bluetooth-core-spec,bluez-l2cap-wiki}.
Кроме того, на стороне Android типовые высокоуровневые API ориентированы на RFCOMM-сервисы, что делает прямую работу с L2CAP при реализации мобильного приложения неоправданным ограничением~\cite{android-bt-connect}.

\subsubsection*{Профиль HID поверх Bluetooth}

Для устройств ввода, Bluetooth-стек предусматривает профиль HID, обеспечивающий транспорт HID-отчётов по каналу L2CAP и интеграцию с HID-core ядра~\cite{bluetooth-core-spec,linux-hid-docs}. Такой подход используется для аппаратных Bluetooth-мышей и клавиатур: транспортный драйвер профиля HID принимает HID-отчёты по Bluetooth и передаёт их в HID-core, где они интерпретируются и преобразуются в события подсистемы ввода~\cite{linux-hid-docs,hidp-core-doc}. Поддержка профиля HIDP на стороне ядра конфигурируется параметром \texttt{CONFIG\_BT\_HIDP} в конфигурации ядра~\cite{config-bt-hidp}.

Применение профиля HID для эмуляции мыши на базе смартфона потребовало бы разработки или адаптации транспортного драйвера, а также формирования корректных HID-описателей и отчётов~\cite{hid-transport,hidintro}. В рамках курсовой работы такая интеграция выходит за пределы необходимого объёма, так как влечёт за собой разработку HID-описателя, поддержку отчётов и согласование с существующей инфраструктурой HID при отсутствии требований к использованию расширенных возможностей HID-протокола~\cite{linux-hid-docs,hiddev-doc}.

\subsubsection*{Использование устройств \texorpdfstring{\texttt{/dev/rfcommN}}{dev/rfcommN} и пользовательского пространства}

Подсистема \texttt{BlueZ} предоставляет возможность отображать RFCOMM-соединения в виде псевдотерминальных устройств \texttt{/dev/rfcommN}, которые доступны пользовательским приложениям как последовательные порты~\cite{bluez-rfcomm-wiki,rfcomm-tty-howto}. Пользовательские программы открывают такие устройства через стандартные системные вызовы и читают поток байтов, реализуя прикладной протокол в пользовательском пространстве~\cite{rfcomm-tty-howto,rfcomm-missing-dev}.

Для интеграции с модулем ядра в этом случае потребовалась бы дополнительная связка между пользовательским процессом, обрабатывающим \texttt{/dev/rfcommN}, и драйвером мыши, например через символьное устройство или вспомогательный интерфейс обмена. Такая архитектура приводит к разделению логики между модулем ядра и пользовательским процессом и увеличивает количество точек отказа. Кроме того, основной функциональный поток управления курсором в этом случае реализуется в пользовательском пространстве, тогда как модуль ядра выполняет вспомогательные функции маршрутизации событий~\cite{linux-driver-basics}.

\subsubsection*{Обоснование выбора RFCOMM-сокета в пространстве ядра}

Сравнение рассмотренных вариантов организации обмена данными по Bluetooth позволяет сформулировать следующие наблюдения:
\begin{itemize}
	\item L2CAP предоставляет универсальный транспортный уровень и используется в качестве основы для протоколов более высокого уровня, однако при прямом использовании влечёт усложнение драйвера за счёт необходимости дополнительной обработки параметров канала~\cite{bluetooth-core-spec,bluez-l2cap-wiki,l2cap-man};
	\item профиль HID ориентирован на аппаратные HID-устройства и предполагает интеграцию с HID-core и существующей реализацией профиля в ядре, что не требуется для протокола обмена фиксированного формата между смартфоном и драйвером мыши~\cite{bluetooth-core-spec,linux-hid-docs,hidp-core-doc,config-bt-hidp};
	\item использование \texttt{/dev/rfcommN} и пользовательских программ переводит основную часть обработки в пользовательское пространство и требует дополнительного канала взаимодействия с модулем ядра~\cite{bluez-rfcomm-wiki,rfcomm-tty-howto,rfcomm-missing-dev,linux-driver-basics};
	\item RFCOMM-сокет в пространстве ядра обеспечивает потоковый канал непосредственно в драйвер, использует реализованный протокол поверх L2CAP и естественно стыкуется с высокоуровневым API Android-приложения, использующим класс \texttt{BluetoothSocket}~\cite{linux-rfcomm-core,kernel-net-kapi,android-bt-connect,BluetoothSocket-doc}.
\end{itemize}

На основании этих соображений в разрабатываемом драйвере выбран подход, основанный на серверном RFCOMM-сокете в пространстве ядра. 
Модуль ядра, фактически, станрвится сервером, к которому присоединяются клиенты с помощью мобильного приложения Android.
Этот сервер обрабатывает сообщения фиксированного формата с данными о перемещении и состояниях кнопок, выполняет обработку входящих данных и синхронно генерирует события подсистемы ввода для виртуального устройства мыши~\cite{linux-input-docs,bluetooth-core-spec,android-bt-connect}. 
Такой стек (виртуальное устройство в подсистеме input и RFCOMM-соединение в пространстве ядра) соответствует постановке задачи и является достаточным для реализации драйвера.

\subsection*{Выводы}

В данном разделе был проведён анализ вариантов интеграции разрабатываемого драйвера с подсистемой ввода и стеком Bluetooth ядра Linux, а также вариантов распределения функциональности между модулем ядра и мобильным приложением. Для генерации событий мыши рассматривались: регистрация виртуального устройства ввода через подсистему input с использованием \lstinline|struct input_dev| и функций \lstinline|input_report_*|, использование подсистемы \lstinline|uinput| из пользовательского пространства и интеграция через подсистему HID и интерфейс UHID. 

В результате выбрана регистрация виртуального устройства мыши в подсистеме input, так как этот подход обеспечивает представление драйвера как полноценного устройства ввода, позволяет формировать события \lstinline|EV_REL| и \lstinline|EV_KEY| непосредственно из модуля ядра и концентрирует основную логику управления курсором в драйвере, а не во внешнем приложении~\cite{linux-input-docs,input-programming,linux-driver-basics}. 

Для организации обмена данными между смартфоном и модулем ядра по Bluetooth были рассмотрены: прямое использование L2CAP, профиль HID (HIDP), отображение RFCOMM-соединения на устройства \lstinline|/dev/rfcommN| с обработкой в пользовательском пространстве и использование протокола RFCOMM в ядре. 

Выбран вариант с серверным RFCOMM-сокетом в пространстве ядра Linux и клиентским \lstinline|BluetoothSocket| в Android-приложении, поскольку он предоставляет потоковый канал поверх L2CAP, естественно поддерживается стеком BlueZ и Android SDK и позволяет передавать бинарные сообщения протокола непосредственно в драйвер без промежуточных пользовательских прослоек~\cite{bluetooth-core-spec,bluez-rfcomm-wiki,linux-rfcomm-core,android-bt-connect,BluetoothSocket-doc}. 

Таким образом, в качестве целевого стека принята схема <<Android-приложение --- RFCOMM --- загружаемый модуль ядра --- подсистема input>>, где модуль ядра принимает команды от мобильного приложения, декодирует их и преобразует в стандартные события виртуальной мыши.
Модель взаимодействия с помощью RFCOMM является достаочной для достижения цели.
