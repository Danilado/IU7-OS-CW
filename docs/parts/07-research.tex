\section{Исследовательский раздел}

\subsection{Технические характеристики}

Проверка работы разработанного программного обеспечения выполнялась на стенде, включающем рабочую станцию под управлением операционной системы семейства Linux и смартфон под управлением Android. Конфигурация стенда приведена ниже.

\subsubsection*{Рабочая станция}

В качестве рабочей станции использован компьютер со следующими характеристиками:
\begin{itemize}
	\item операционная система: Arch Linux x86\_64;
	\item ядро: Linux 6.17.9-zen1-1-zen;
	\item объём оперативной памяти: 32 Гб;
	\item процессор: AMD Ryzen 7 7700 (16) @ 5.39 ГГц;
	\item графический процессор №1: NVIDIA GeForce RTX 3080 Ti [Дискретный];
	\item графический процессор №2: AMD Raphael [Интегрированный];
	\item встроенный Bluetooth-адаптер, поддерживающий профили, реализуемые стеком BlueZ (RFCOMM поверх L2CAP);
\end{itemize}

Указанная конфигурация достаточна для загрузки загружаемого модуля ядра, регистрации виртуального устройства ввода типа «мышь» и приёма событий по RFCOMM-соединению от мобильного приложения.

\subsubsection*{Мобильное устройство}

В качестве мобильного устройства использован смартфон со следующими характеристиками:
\begin{itemize}
	\item операционная система: Android 16;
	\item модуль Bluetooth, поддерживающий работу в режиме классического Bluetooth и установление RFCOMM-соединений;
	\item сенсорный экран с поддержкой многоточечного ввода;
	\item объём оперативной памяти: 12 Гб;
	\item процессор: Google Tensor G3; 
\end{itemize}

Выбранная конфигурация обеспечивает установление RFCOMM-соединения со стороны Android-приложения, обработку жестов на сенсорном экране и формирование бинарных сообщений протокола для передачи в модуль ядра.

\subsection{Демонстрация работы программы}

Демонстрация работы разработанного решения проводилась в виде набора экспериментальных сценариев, охватывающих установление соединения, управление курсором и генерацию событий нажатия кнопок мыши.

Перед запуском мобильного приложения на рабочей станции выполнялась загрузка загружаемого модуля ядра \texttt{phone\_mouse\_bt}. При загрузке модуль регистрировал виртуальное устройство ввода в подсистеме \lstinline|input|, создавал серверный RFCOMM-сокет и запускал служебный поток \lstinline|rx_loop|, ожидающий входящего соединения от смартфона. В системном журнале ядра фиксировалось сообщение о готовности модуля и номере прослушиваемого RFCOMM-канала.

На стороне мобильного устройства запускалось Android-приложение. Пользователь вводил MAC-адрес Bluetooth-адаптера рабочей станции в соответствующее текстовое поле и инициировал подключение. Приложение получало объект \lstinline|BluetoothDevice| по указанному MAC-адресу, создавалось RFCOMM-соединение с указанным каналом, после успешного выполнения операции \lstinline|connect| сохранялись объекты \lstinline|BluetoothSocket| и \lstinline|OutputStream|, и на экране отображалось уведомление об успешном подключении.

Графический интерфейс мобильного приложения содержит:
\begin{itemize}
	\item область touchpad, в которой обрабатываются жесты перемещения пальца и вычисляются относительные смещения по осям;
	\item две кнопки, инициирующие логические события нажатия левой и правой кнопок мыши;
	\item поле ввода MAC-адреса рабочего устройства.
\end{itemize}

Интерфейс мобильного приложения показан на рис.~\ref{fig:phone-interface}. Сенсорная область занимает центральную часть экрана, кнопки мыши расположены в нижней части, поле ввода MAC-адреса --- в верхней части интерфейса.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\textwidth]{phone_interface.jpg}
	\caption{Интерфейс мобильного приложения управления курсором}
	\label{fig:phone-interface}
\end{figure}

При перемещении пальца пользователя по области touchpad приложение фиксирует координаты касания, вычисляет относительные смещения по осям \texttt{dx} и \texttt{dy} и накапливает их во внутренних переменных \lstinline|pendingDx| и \lstinline|pendingDy|. В отдельном фоновом потоке с фиксированным интервалом времени выполняется чтение накопленных смещений под защитой синхронизации, после чего при ненулевом значении хотя бы одной из компонент формируется бинарный пакет из пяти байт (код кнопок и смещения по осям) и передаётся в модуль ядра через \lstinline|BluetoothSocket|.

При нажатии на кнопку, соответствующую левой или правой кнопке мыши, приложение вызывает функцию формирования пакета с нулевыми смещениями и установленным кодом нужной кнопки. В результате в модуль ядра поступает пакет с соответствующей маской кнопок, а функция \lstinline|handle\_buttons| генерирует последовательность событий \lstinline|BTN\_LEFT| или \lstinline|BTN\_RIGHT|. На стороне рабочей станции это проявляется в виде стандартных действий графической среды: выделения объектов, вызова контекстного меню и других операций, связанных с нажатием соответствующих кнопок мыши.

В ходе демонстрации проверялись следующие сценарии:
\begin{itemize}
	\item установление и закрытие RFCOMM-соединения при корректном и некорректном MAC-адресе;
	\item устойчивое перемещение курсора по экрану рабочей станции при различных траекториях движения пальца по сенсорной области;
	\item корректная генерация событий нажатия левой и правой кнопок мыши и их обработка оконной системой;
	\item работа системы при изменении параметров скорости и числа шагов интерполяции движения, задаваемых параметрами модуля.
\end{itemize}

Во всех указанных сценариях виртуальное устройство мыши, регистрируемое модулем ядра, корректно обрабатывало события, поступающие от мобильного приложения, а взаимодействие с графической средой рабочей станции происходило через стандартный стек ввода операционной системы. Набор сценариев демонстрирует соответствие ключевым требованиям ТЗ: управление курсором и кнопками со смартфона по Bluetooth посредством загружаемого модуля ядра.
