\subsection{Способы обмена данными между телефоном и модулем ядра}

Передача данных между мобильным устройством и загружаемым модулем ядра может быть реализована различными способами, включая сетевые протоколы, каналы межпроцессного взаимодействия через пользовательское пространство и беспроводные стеки передачи данных.

Для решения поставленной задачи выбрано беспроводное соединение по технологии Bluetooth. Оно обеспечивает устойчивый двунаправленный канал связи, нативно поддерживается в ядре Linux через подсистему \texttt{BlueZ} и предоставляет API, совместимый с типовыми средствами разработки Android-приложений.

Стек Bluetooth в Linux реализуется в виде подсистемы \texttt{BlueZ}, включающей поддержку базового протокола L2CAP, протокола RFCOMM, профиля HID и вспомогательных служб~\cite{bluetooth-core-spec,bluez-l2cap-wiki,bluez-rfcomm-wiki}. На уровне ядра для взаимодействия с Bluetooth-устройствами используются сокеты семейства \texttt{PF\_BLUETOOTH} с такими протоколами, как \texttt{BTPROTO\_L2CAP} и \texttt{BTPROTO\_RFCOMM}~\cite{bluetooth-core-spec,kernel-net-kapi}. В пространстве ядра доступен интерфейс для создания и использования таких сокетов, обеспечивающий работу с Bluetooth-соединениями без участия пользовательского процесса~\cite{kernel-net-kapi}.

С точки зрения обмена данными между смартфоном и модулем ядра возможны следующие варианты:
\begin{enumerate}
	\item использование RFCOMM-сокетов в пространстве ядра;
	\item работа непосредственно с L2CAP в пространстве ядра;
	\item задействование профиля HID поверх Bluetooth;
	\item использование устройств \texttt{/dev/rfcommN} и пользовательского пространства.
\end{enumerate}

\

\textit{RFCOMM-сокеты в пространстве ядра}

Протокол RFCOMM реализует поверх L2CAP байтовый поток, логически аналогичный последовательному порту, и применяется для построения сервисов, требующих надёжного двунаправленного канала~\cite{bluetooth-core-spec,bluez-rfcomm-wiki}. В ядре Linux поддержка RFCOMM интегрирована в сетевой стек, что позволяет создавать серверные и клиентские сокеты с использованием семейства \texttt{PF\_BLUETOOTH} и протокола \texttt{BTPROTO\_RFCOMM}~\cite{bluetooth-core-spec,linux-rfcomm-core}. Адресация RFCOMM-сокета выполняется с использованием структуры адреса, содержащей семейство, Bluetooth-адрес удалённого устройства и номер канала.

На стороне Android-приложения подключение к такому сервису реализуется через API класса \texttt{BluetoothSocket}, который инкапсулирует установление RFCOMM-соединения по указанному UUID сервиса~\cite{android-bt-connect,BluetoothSocket-doc}. Таким образом реализуется связка: серверный RFCOMM-сокет в пространстве ядра и клиентское соединение в приложении Android.

При использовании RFCOMM модуль ядра получает поток байтов непосредственно от смартфона, что позволяет задать прикладной протокол управления курсором (например, фиксированный формат кадров с координатами и битовой маской кнопок) без вовлечения дополнительных уровней абстракции~\cite{bluetooth-core-spec,bluez-rfcomm-wiki}. Обработка входящего потока выполняется в  обработчиках на стороне загружаемого модуля ядра, что упрощает синхронизацию с подсистемой ввода~\cite{kernel-net-kapi}.

\

\textit{Использование L2CAP в пространстве ядра}

L2CAP представляет собой базовый протокол Bluetooth, обеспечивающий мультиплексирование каналов и передачу пакетов между устройствами~\cite{bluetooth-core-spec,bluez-l2cap-wiki}. Прямое использование L2CAP даёт доступ к более низкому уровню стека и предоставляет гибкость при реализации собственных протоколов, но требует дополнительной обработки параметров канала и управления MTU~\cite{l2cap-man}.

В контексте рассматриваемой задачи использование L2CAP в качестве средства передачи данных для прикладного протокола управления курсором приводит к усложнению логики модуля ядра и дублированию функциональности, уже реализованной в RFCOMM, как надстройке над L2CAP~\cite{bluetooth-core-spec,bluez-l2cap-wiki}.
Кроме того, на стороне Android типовые высокоуровневые API ориентированы на RFCOMM-сервисы, что делает прямую работу с L2CAP при реализации мобильного приложения неоправданным ограничением~\cite{android-bt-connect}.

\

\textit{Профиль HID поверх Bluetooth}

Для устройств ввода, Bluetooth-стек предусматривает профиль HID, обеспечивающий транспорт HID-отчётов по каналу L2CAP и интеграцию с HID-core ядра~\cite{bluetooth-core-spec,linux-hid-docs}. Такой подход используется для аппаратных Bluetooth-мышей и клавиатур: транспортный драйвер профиля HID принимает HID-отчёты по Bluetooth и передаёт их в HID-core, где они интерпретируются и преобразуются в события подсистемы ввода~\cite{linux-hid-docs,hidp-core-doc}. Поддержка профиля HIDP на стороне ядра конфигурируется параметром \texttt{CONFIG\_BT\_HIDP} в конфигурации ядра~\cite{config-bt-hidp}.

Применение профиля HID для эмуляции мыши на базе смартфона потребовало бы разработки или адаптации транспортного драйвера, а также формирования корректных HID-описателей и отчётов~\cite{hid-transport,hidintro}. В рамках курсовой работы такая интеграция выходит за пределы необходимого объёма, так как влечёт за собой разработку HID-описателя, поддержку отчётов и согласование с существующей инфраструктурой HID при отсутствии требований к использованию расширенных возможностей HID-протокола~\cite{linux-hid-docs,hiddev-doc}.

\

\textit{Использование устройств \texorpdfstring{\texttt{/dev/rfcommN}}{dev/rfcommN} и пользовательского пространства}

Подсистема \texttt{BlueZ} предоставляет возможность отображать RFCOMM-соединения в виде псевдотерминальных устройств \texttt{/dev/rfcommN}, которые доступны пользовательским приложениям как последовательные порты~\cite{bluez-rfcomm-wiki,rfcomm-tty-howto}. Пользовательские программы открывают такие устройства через стандартные системные вызовы и читают поток байтов, реализуя прикладной протокол в пользовательском пространстве~\cite{rfcomm-tty-howto,rfcomm-missing-dev}.

Для интеграции с модулем ядра в этом случае потребовалась бы дополнительная связка между пользовательским процессом, обрабатывающим \texttt{/dev/rfcommN}, и драйвером мыши, например через символьное устройство или вспомогательный интерфейс обмена. Такая архитектура приводит к разделению логики между модулем ядра и пользовательским процессом и увеличивает количество точек отказа. Кроме того, основной функциональный поток управления курсором в этом случае реализуется в пользовательском пространстве, тогда как модуль ядра выполняет вспомогательные функции маршрутизации событий~\cite{linux-driver-basics}.

\

\textit{Обоснование выбора RFCOMM-сокета в пространстве ядра}

В результате анализа способов передачи данных в модуль ядра по протоколу Bluetooth, получены следующие выводы:
\begin{itemize}
	\item L2CAP предоставляет универсальный транспортный уровень и используется в качестве основы для протоколов более высокого уровня, однако при прямом использовании влечёт усложнение драйвера за счёт необходимости дополнительной обработки параметров канала~\cite{bluetooth-core-spec,bluez-l2cap-wiki,l2cap-man};
	\item профиль HID ориентирован на аппаратные HID-устройства и предполагает интеграцию с HID-core и существующей реализацией профиля в ядре, что не требуется для протокола обмена фиксированного формата между смартфоном и драйвером мыши~\cite{bluetooth-core-spec,linux-hid-docs,hidp-core-doc,config-bt-hidp};
	\item использование \texttt{/dev/rfcommN} и пользовательских программ переводит основную часть обработки в пользовательское пространство и требует дополнительного канала взаимодействия с модулем ядра~\cite{bluez-rfcomm-wiki,rfcomm-tty-howto,linux-driver-basics};
	\item RFCOMM-сокет в пространстве ядра обеспечивает потоковый канал непосредственно в драйвер, использует реализованный протокол поверх L2CAP и поддерживает соединение с высокоуровневым API Android-приложения~\cite{linux-rfcomm-core,kernel-net-kapi,android-bt-connect,BluetoothSocket-doc}.
\end{itemize}

На основании этих соображений в разрабатываемом драйвере выбран подход, основанный на серверном RFCOMM-сокете в пространстве ядра. 
Модуль ядра, фактически, становится сервером, к которому присоединяются клиенты с помощью мобильного приложения Android.
Этот сервер обрабатывает сообщения фиксированного формата с данными о перемещении и состояниях кнопок, выполняет обработку входящих данных и синхронно генерирует события подсистемы ввода для виртуального устройства мыши~\cite{linux-input-docs,bluetooth-core-spec,android-bt-connect}. 
Такой стек (виртуальное устройство в подсистеме input и RFCOMM-соединение в пространстве ядра) соответствует постановке задачи и является достаточным для реализации драйвера.
