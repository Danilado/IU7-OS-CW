\subsection{Анализ способов управления курсором мыши из загружаемого модуля ядра}

Для генерации событий подсистемы ввода рассмотрено два подхода: регистрация собственного виртуального устройства в подсистеме input и вмешательство в существующий стек ввода (перехват/модификация событий уже зарегистрированных устройств или графической подсистемы).

\

\textit{Виртуальное устройство в подсистеме input}

Этот способ заключается в регистрации виртуального устройства мыши через подсистему input~\cite{linux-input-docs,input-programming}. Модуль выделяет и инициализирует \texttt{struct input\_dev}, настраивает поддержку событий \texttt{EV\_REL} (\texttt{REL\_X}, \texttt{REL\_Y}) и \texttt{EV\_KEY} (\texttt{BTN\_LEFT}, \texttt{BTN\_RIGHT}), после чего регистрирует устройство в input-core~\cite{linux-input-docs}. Структура \texttt{input\_dev} и функции \texttt{input\_report\_*} объявлены в заголовочном файле \texttt{<linux/input.h>} ядра Linux. Генерация событий выполняется вызовами \texttt{input\_report\_rel}, \texttt{input\_report\_key} и \texttt{input\_sync}, что делает виртуальное устройство эквивалентным аппаратной мыши для остального стека ввода~\cite{linux-input-docs}.

Структура \texttt{struct input\_dev} приведена в листинге~\ref{lst:input_dev}.

\begin{lstlisting}[language=C,caption={Структура \texttt{input\_dev}},label={lst:input_dev}]
	struct input_dev {
		const char * name;
		const char * phys;
		const char * uniq;
		struct input_id id;
		unsigned long propbit;
		unsigned long evbit;
		unsigned long keybit;
		unsigned long relbit;
		unsigned long absbit;
		unsigned long mscbit;
		unsigned long ledbit;
		unsigned long sndbit;
		unsigned long ffbit;
		unsigned long swbit;
		unsigned int hint_events_per_packet;
		unsigned int keycodemax;
		unsigned int keycodesize;
		void * keycode;
		int (* setkeycode) (struct input_dev *dev,const struct input_keymap_entry *ke, unsigned int *old_keycode);
		int (* getkeycode) (struct input_dev *dev, struct input_keymap_entry *ke);
		struct ff_device * ff;
		unsigned int repeat_key;
		struct timer_list timer;
		int rep;
		struct input_mt * mt;
		struct input_absinfo * absinfo;
		unsigned long key;
		unsigned long led;
		unsigned long snd;
		unsigned long sw;
		int (* open) (struct input_dev *dev);
		void (* close) (struct input_dev *dev);
		int (* flush) (struct input_dev *dev, struct file *file);
		int (* event) (struct input_dev *dev, unsigned int type, unsigned int code, int value);
		struct input_handle __rcu * grab;
		spinlock_t event_lock;
		struct mutex mutex;
		unsigned int users;
		bool going_away;
		struct device dev;
		struct list_head h_list;
		struct list_head node;
		unsigned int num_vals;
		unsigned int max_vals;
		struct input_value * vals;
		bool devres_managed;
	};
\end{lstlisting}

\

\textit{Перехват или модификация существующего стека ввода}

Альтернативный вариант — вмешательство в уже зарегистрированные устройства или обработчики графической подсистемы (например, перехват операций \lstinline|/dev/input/eventX|, модификация обработчиков оконной системы). Такой подход требует изменения существующих компонентов стека ввода или добавления промежуточных слоёв, усложняет сопровождение и увеличивает количество точек отказа. Кроме того, он не создаёт самостоятельного модуля ядра для эмуляции мыши, что расходится с задачей разработки отдельного загружаемого модуля.
